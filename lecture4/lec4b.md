# Why do you think requirements change so much?

- It is difficult to predict in advance whichÂ  software requirements will persist and which will change.

- It is equally difficult to predict how customer priorities will change as the project proceeds.

- It is often difficult for people to verbalize their software needs until they see a **working prototype** and realize that they had forgotten to consider something important

# Why prototype?

- Prototyping is commonly a means for **validating** the software engineer's **interpretation** of the software requirements, as well as for **eliciting** new requirements
- The **advantage** of prototype is that they can make it **easier** to **interpret** the software engineer's **assumptions** and, _where needed, give useful feedback on why they are wrong._
- For example, the dynamic behaviour of a user interface can be better understood through an animated prototype than through textual description or graphical models.

# Prototyping

- Prototypes for requirements validation demonstrate the requirements and help stakeholders discover problems
- **Analysis prototypes** can be lightweight and need not contain SW at all, they are for discovering what users want
- **Validation prototypes** should be complete, reasonably efficient and robust. It should be possible to use them in the same way as the required system
- User documentation and training should be provided

# Types of prototype

- **Software**: create a new executable prototype
  - Use rapid prototyping tools (e.g. UI as html forms)
- Write a first **draft** of the user interface
  - Incremental development
- Modify existing SW to create a prototype for the new system
- Generate screen mock-ups with drawing software (e.g. powerpoint is fine)
- Draw mock-ups on white-boards or paper

# Provide three examples of software that are amenable to the prototyping model. Be specific

- Software applications that are relatively easy to prototype almost always involve **human-machine interaction** and/or heavy computer graphics.
- Other applications that are sometimes amenable to prototyping are certain classes of **mathematical algorithms**, subset of **command driven systems** and other applications where results can be easily examined without real-time interaction.
- Application that are difficult to prototype include control and process control functions, many classes of real-time applications and embedded software.

# User manual development

- Writing a user manual from the requiremnts forces a detailed requirements analysis and thus can reveal problems with the document
- Information in the user manual
  - Description of the functionality and how it is implemented
  - Which parts of the system have not been implemented
  - How to get out of trouble
  - How to install and get started with system

# Summary

- **Prototyping** is effective for requirements validation if it is in the initial stages of software engineering
- Prototyping can be physical (e.g. on paper) or written as software
- Writing a user manual early can help to clarify requirements.
